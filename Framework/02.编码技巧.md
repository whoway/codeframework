# â™»ï¸ç¼–ç æŠ€å·§



## ğŸ“‘ ç›®å½•

- â­ï¸ä¸€ã€åŒæŒ‡é’ˆ
- âœ¡ï¸äºŒã€é€’å½’
- ğŸ€ä¸‰ã€å°†ã€æ ˆå’Œé€’å½’ã€è½¬æ¢å¾—ç‚‰ç«çº¯é’
- âœï¸å››ã€è¿­ä»£
- â˜ï¸äº”ã€ç©ºé—´æ¢æ—¶é—´
- ğŸ’«å…­ã€è®¡ç®—ä¸­ç¼€è¡¨è¾¾å¼







## ğŸ’¬ä¸€ã€åŒæŒ‡é’ˆ

- æœ‰çš„ä¹¦ä¸Šå«â€œå°ºå–æ³•â€

### 1ã€ç»¼è¿°ï¼šåŒæŒ‡é’ˆçš„å¸¸è§æŠ€å·§

- å¿«æ…¢æŒ‡é’ˆï¼ˆfastå’Œlowï¼‰
- å·¦å³æŒ‡é’ˆï¼ˆleftå’Œrightï¼‰
- æ»‘åŠ¨çª—å£





### 2ã€lowå’ŒfastæŒ‡é’ˆã€å¿«æ…¢æŒ‡é’ˆã€

```cpp
//æ¡†æ¶å¼€å§‹
ListNode * low=pHead;
ListNode * fast=pHead;

while( nullptr!=fast->next && nullptr!=fast->next->next )
{
    //è®°å¾—ä¸€å®šè¦å…ˆèµ°
	low=low->next;
	fast=fast->next->next;
//æ¡†æ¶ç»“æŸ
	if( low==fast )
    {
        low=pHead;
        while( low!=fast )
        {
            low=low->next;
            fast=fast->next;
        }
        return fast;
    }
```


### 3ã€å·¦å³æŒ‡é’ˆ

- äºŒåˆ†æŸ¥æ‰¾ç”¨åˆ°äº†
- åˆ¤æ–­æ˜¯å¦å›æ–‡



### 4ã€æ»‘åŠ¨çª—å£ã€æ¨¡æ¿ã€

- æ¡†æ¶

```txt
string str;
int Left=0,Right=0,Len=str.size();
while( Right<Len )
{
	//å³ä¾§å¼ºåˆ¶æ›´æ–°çš„,ä¸‹é¢å¿…é¡»ä¿ç•™ï¼Œå¦åˆ™++Rightä¹‹åä¼šæ›´æ–°
    char CurChar=s[Right];
    WindowsHash[ CurChar ]++;
    ++Right;
    //å³ä¾§éå¼ºåˆ¶æ›´æ–°çš„ï¼Œæœ¬éƒ¨åˆ†ä¸éœ€è¦æ›´æ–°
            

	//ã€ä½•æ—¶ä½¿å¾—çª—å£ä¸ç¬¦åˆæ¡ä»¶ã€ï¼Œä½¿å¾—å·¦ä¾§éœ€è¦æ›´æ–°ï¼Ÿæ”¶ç¼©ï¼Ÿ
	//ç”¨çš„whileå¾ªç¯æ”¶ç¼©ï¼Œæ¯•ç«Ÿå¯èƒ½è¦æ”¶ç¼©å¾ˆå¤šæ¬¡
	while( how to shrink)
	{
        char c=s[Left];
        WindowsHash[c]--;
        ++Left;
        //å…¶ä»–çš„
	}
}
```



#### ä¾‹é¢˜1-[26. åˆ é™¤æœ‰åºæ•°ç»„ä¸­çš„é‡å¤é¡¹](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/)

- ä¸¥æ ¼æ¥è¯´æ˜¯â€œå·¦å³æŒ‡é’ˆâ€ï¼Œä¸å…¨æ˜¯â€œæ»‘åŠ¨çª—å£â€

```cpp
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
 
        int Left=0;
        int Right=1; //â€œæ»‘åŠ¨çª—å£â€åœ¨æœ¬é¢˜ä¸­çš„æ”¹è¿›ç‚¹1
        int Len=nums.size();

        while( Right<Len )
        {
            //æ”¹è¿›ç‚¹2
            if( nums[Right]==nums[Left] )
            {
                nums.erase( nums.begin()+Right, nums.begin()+Right+1 );
                --Len;
            }
            else if( nums[Right]!=nums[Left] )
            {
                ++Left;
                ++Right;
            }
        }


        return Len;
    }
};
```



#### ä¾‹é¢˜2-[3. æ— é‡å¤å­—ç¬¦çš„æœ€é•¿å­ä¸²](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)



```cpp
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        int res=0;
        unordered_map<char,int> WindowsHash;
        int Left=0,Right=0;
        int Len=s.size();

        while( Right<Len )
        {
            //å³ä¾§å¼ºåˆ¶æ›´æ–°çš„,ä¸‹é¢å¿…é¡»ä¿ç•™ï¼Œå¦åˆ™++Rightä¹‹åä¼šæ›´æ–°
            char CurChar=s[Right];
            WindowsHash[ CurChar ]++;
            ++Right;
            //å³ä¾§éå¼ºåˆ¶æ›´æ–°çš„ï¼Œæœ¬éƒ¨åˆ†ä¸éœ€è¦æ›´æ–°
            

            //ã€ä½•æ—¶ä½¿å¾—çª—å£ä¸ç¬¦åˆæ¡ä»¶ã€ï¼Œä½¿å¾—å·¦ä¾§éœ€è¦æ›´æ–°ï¼Ÿæ”¶ç¼©ï¼Ÿ
            while( WindowsHash[ CurChar ] >1 )
            {
                char c=s[Left];
                WindowsHash[c]--;
                ++Left;
            }

            res=max( res, Right-Left );
        }

        return res;
    }
};
```







## âœ¡ï¸äºŒã€é€’å½’

### 1ã€é€’å½’å¥—è·¯ã€é‡è¦ã€

- æ¥è‡ªã€Šç®—æ³•åŸºç¡€ä¸åœ¨çº¿å®è·µã€‹

```cpp
#include<bits/stdc++.h>
using namespace std;

int n;
//è¡¨ç¤ºï¼Œbeginå€ŸåŠ©helpæ†å­ï¼Œåˆ°endä¸Šé¢å»ï¼Œè¿™æ¬¡çš„ç›®æ ‡æ˜¯ç§»åŠ¨nä¸ªå…ƒç´ 
void hanota(char begin, char help, char end, int n)
{
	if( n<1 )	return ;
	if( 1==n ) 
	{
		printf("%c->%c\n", begin, end);
		return ;
	}

	//è¿™ä¸ªé€’å½’ï¼Œæ˜¯è§‚å¯Ÿå°éƒ¨åˆ†çš„è°ƒç”¨è·å¾—çš„idea
	hanota( begin, end, help, n-1);
	printf("%c->%c\n", begin, end);
	hanota( help, begin, end, n-1);
}

int main()
{
	while( ~scanf("%d",&n) )
	{
		hanota( 'A', 'B', 'C', n);
	}

	return 0;
}
```


















## ğŸ€ä¸‰ã€å°†ã€æ ˆå’Œé€’å½’ã€è½¬æ¢å¾—ç‚‰ç«çº¯é’

- äºŒå‰æ ‘çš„[å‰åºéå†](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/submissions/)

### ï¼ˆ1ï¼‰é€’å½’è½¬æ ˆã€ä¸‡èƒ½æ¨¡æ¿ã€



```txt
0ã€ä½¿ç”¨ç»“æ„ä½“é‡çš„æˆå‘˜å˜é‡æˆ–æŒ‡é’ˆå˜ï¼ŒæŠ½è±¡åŸå…ˆè§£å†³é—®é¢˜çš„ã€é€’å½’å‡½æ•°ã€çš„å½¢å¼å‚æ•°
1ã€è®¾ç½® ã€é—®é¢˜æ ˆã€å¹¶ä¸”ï¼Œç”»å‡ºå’Œä¹¦ä¸Šå·®ä¸å¤šçš„è§£å†³é—®é¢˜ï¼Œæ ˆå˜åŒ–è¡¨
2ã€åˆå§‹åŒ–ã€ç¬¬1ä¸ªé—®é¢˜ã€
    st.push( root );
3ã€ç”¨whileå¾ªç¯ï¼Œæ¨¡æ‹Ÿæ ˆ
```

- éƒ­ç‚œï¼Œã€Š[ç®—æ³•åŸºç¡€ä¸åœ¨çº¿å®è·µ](https://book.douban.com/subject/27023415/)ã€‹P74ï¼Œé€’å½’å’Œæ ˆçš„è§£æ³•
- ç‡è¾‰ï¼Œ2020ç‰ˆ[æ•°æ®ç»“æ„é«˜åˆ†ç¬”è®°](https://book.douban.com/subject/30777887/)ï¼ˆç¬¬8ç‰ˆï¼‰



### ï¼ˆ2ï¼‰é€’å½’è§£æ³•

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */

vector<int> ret;

void trave( TreeNode * root )
{
    if( nullptr==root )
    {
        return ;
    }

    ret.push_back( root->val );
    trave( root->left );
    trave( root->right );
}
class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) {
        
        ret.clear();
        trave( root );
        return ret;
    }
};
```



### ï¼ˆ3ï¼‰æ ˆè§£æ³•

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */

vector<int> ret;
stack< TreeNode * > st;//ç¬¬1æ­¥ï¼Œè®¾ç½® ã€é—®é¢˜æ ˆã€
void trave( TreeNode * root )
{
    //ç¬¬2æ­¥ï¼Œåˆå§‹åŒ–ã€ç¬¬1ä¸ªé—®é¢˜ã€
    st.push( root );

    //ç¬¬3æ­¥ï¼Œç”¨whileå¾ªç¯ï¼Œæ¨¡æ‹Ÿæ ˆ
    while( !st.empty() )
    {
        TreeNode * top=st.top();
        st.pop();

        if( nullptr!=top )
        {
            st.push ( top->right );
            st.push( top->left );
            ret.push_back( top->val ); //ç€æ‰‹è§£å†³é—®é¢˜
        }
    }

}
class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) {
        
        ret.clear();
        while( !st.empty() )
        {
            st.pop();
        }
        trave( root );
        return ret;
    }
};
```



## âœï¸å››ã€è¿­ä»£

- é“¾è¡¨éå†

```cpp
void  MyReverse( ListNode * root )
{
    while( nullptr!=root )
    {
        cout<< (root->val) <<endl;
        root = root->next;
    }
}
```





## â˜ï¸äº”ã€ç©ºé—´æ¢æ—¶é—´

- æ¯”å¦‚ï¼Œæ±‚ç´ æ•°



## ğŸ’«å…­ã€è®¡ç®—ä¸­ç¼€è¡¨è¾¾å¼













